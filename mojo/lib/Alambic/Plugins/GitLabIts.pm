package Alambic::Plugins::GitLabIts;

use strict; 
use warnings;

use Alambic::Model::RepoFS;
use Alambic::Tools::R;

use GitLab::API::v4;
use Mojo::JSON qw( decode_json encode_json );
use Date::Parse;
use Time::Piece;
use Time::Seconds;
use Text::CSV;
use Data::Dumper;

# Main configuration hash for the plugin
my %conf = (
    "id" => "GitLabIts",
    "name" => "GitLab ITS",
    "desc" => [
	'This plugin retrieves Issue Tracking Information from a GitLab server',,
	'For more information on this plugin see the official documentation on the project web site: <a href=\"http://alambic.io/Plugins/Pre/GitLabIts.html\">http://alambic.io/Plugins/Pre/GitLabIts.html</a>.'
    ],
    "type" => "pre",
    "ability" => [ 'metrics', 'info', 'data', 'recs', 'figs', 'viz' ],
    "params" => {
        "gitlab_url" => "The URL of the GitLab instance, e.g. http://www.gitlab.com.",
        "gitlab_id" => "The ID used to identify the project in the GitLab forge.",
        "gitlab_token" => "The private token used to access the gitlab instance. The private token must be generated by a user who has global rights on all analysed projects. It is generated, downlaoded and reset from the user's account page (/profile/account).",
    },
    "provides_cdata" => [
    ],
    "provides_info" => [
      "ITS_URL",
    ],
    "provides_data" => {
	"import_gitlab_its.json" => "Original JSON file as retrieved from the GitLab server (JSON).",
	"gitlab_its_issues.json" => "Restricted (attributes-wise) set of issues extracted from the "
            . "server (JSON).",
	"gitlab_its_issues.csv" => 
	    "Restricted (attributes-wise) set of issues extracted from the server (CSV).",
	"gitlab_its_issues_late.csv" => 
	    "Restricted (attributes-wise) set of late (at the time of analysis)) issues "
            . "extracted from the server (CSV).",
	"gitlab_its_issues_open.csv" => 
	    "Restricted (attributes-wise) set of open issues extracted from the server (CSV).",
	"gitlab_its_issues_open_old.csv" => 
	    "Restricted (attributes-wise) set of open, old (not updated for more than one year) issues extracted from the server (CSV).",
	"gitlab_its_milestones.csv" => 
	    "Restricted (attributes-wise) set of milestones for the project, with number of opened and closed issues (CSV).",
    },
    "provides_metrics" => {
        "ITS_UPDATED_1W" => "ITS_UPDATED_1W", 
        "ITS_UPDATED_1M" => "ITS_UPDATED_1M", 
        "ITS_UPDATED_1Y" => "ITS_UPDATED_1Y", 
        "ITS_CREATED_1W" => "ITS_CREATED_1W", 
        "ITS_CREATED_1M" => "ITS_CREATED_1M", 
        "ITS_CREATED_1Y" => "ITS_CREATED_1Y", 
	"ITS_OPEN" => "ITS_OPEN",
	"ITS_OPEN_OLD" => "ITS_OPEN_OLD",
	"ITS_CLOSED" => "ITS_CLOSED",
	"ITS_ISSUES_ALL" => "ITS_ISSUES_ALL",
	"ITS_LATE" => "ITS_LATE",
	"ITS_UNASSIGNED" => "ITS_UNASSIGNED",
	"ITS_OPEN_UNASSIGNED" => "ITS_OPEN_UNASSIGNED",
	"ITS_TOTAL_DOWNVOTES" => "ITS_TOTAL_DOWNVOTES",
	"ITS_TOTAL_UPVOTES" => "ITS_TOTAL_UPVOTES",
	"ITS_AUTHORS" => "ITS_AUTHORS",
	"ITS_AUTHORS_1W" => "ITS_AUTHORS_1W",
	"ITS_AUTHORS_1M" => "ITS_AUTHORS_1M",
	"ITS_AUTHORS_1Y" => "ITS_AUTHORS_1Y",
	"ITS_PEOPLE" => "ITS_PEOPLE",
    },
    "provides_figs" => {
        'its_evol_summary.rmd' => "its_evol_summary.html",
    },
    "provides_recs" => [
        "ITS_LONG_STANDING_OPEN",
    ],
    "provides_viz" => {
        "gitlab_its.html" => "GitLab ITS",
    },
);


# Constructor
sub new {
    my ($class) = @_;
    
    return bless {}, $class;
}


sub get_conf() {
    return \%conf;
}


# Run plugin: retrieves data + compute_data 
sub run_plugin($$) {
    my ($self, $project_id, $conf) = @_;
    
    my %ret = (
	'metrics' => {},
	'info' => {},
	'recs' => [],
	'log' => [],
	);

    # Create RepoFS object for writing and reading files on FS.
    my $repofs = Alambic::Model::RepoFS->new();

    my $gl_url = $conf->{'gitlab_url'};
    my $gl_id = $conf->{'gitlab_id'};
    my $gl_token = $conf->{'gitlab_token'};

    $ret{'info'}{'ITS_URL'} = $gl_url . '/' . $gl_id . '/issues';
    
    push( @{$ret{'log'}}, "[Plugins::GitLabIts] Retrieving data from [$gl_url] for project [$gl_id]." ); 

    # Create GitLab API object for all rest operations.
    my $api = GitLab::API::v4->new(
        url   => $gl_url . "/api/v4",
        private_token => $gl_token,
	);
    
    # Request information about issues for this specific project.
    my $issues = $api->paginator( 'issues', $gl_id )->all;

    push( @{$ret{'log'}}, "[Plugins::GitLabIts] Retrieved " . scalar @$issues . " issues from server." ); 
    
    # Write the original file to disk.
    my $project_json = encode_json($issues);
    $repofs->write_input( $project_id, "import_gitlab_its.json", $project_json );
    my $issues_vol = scalar @$issues;

    # Store all issues in our own array
    my @issues_f;
    
    # Will contain metrics and aggregated information.
    my ($issues_closed, $issues_open, 
	$issues_created_1w, $issues_created_1m, $issues_created_1y,
	$issues_changed_1w, $issues_changed_1m, $issues_changed_1y,
	$total_upvotes, $total_downvotes) = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    my (@issues_unassigned, @issues_unassigned_open, @issues_late, @issues_open_old);
    my (%milestones, %authors, %authors_1w, %authors_1m, %authors_1y, %people, %notes);

    # Time::Piece object. Will be used for the date calculations.
    my $t_now = localtime;
    my $t_1w = $t_now - ONE_WEEK;
    my $t_1m = $t_now - ONE_MONTH;
    my $t_1y = $t_now - ONE_YEAR;
    
    foreach my $issue (@$issues) {
	# local issue we're going to push.
	my %issues_l; 
	$issues_l{'id'} = $issue->{'iid'};
	$issues_l{'title'} = $issue->{'title'};
	$issues_l{'web_url'} = $issue->{'web_url'};
	$issues_l{'state'} = $issue->{'state'};
	$issues_l{'upvotes'} = $issue->{'upvotes'};
	$issues_l{'downvotes'} = $issue->{'downvotes'};
	$issues_l{'created_at'} = $issue->{'created_at'};
	$issues_l{'updated_at'} = $issue->{'updated_at'};
	$issues_l{'due_date'} = $issue->{'due_date'};
	$issues_l{'user_notes_count'} = $issue->{'user_notes_count'}; 

	if ( $issue->{'state'} =~ m!^open! ) {
	    $issues_open++;
	} elsif ( $issue->{'state'} =~ m!^closed! ) {
	    $issues_closed++;
	} else {
	    push( @{$ret{'log'}}, "[Plugins::GitLabIts] Error identifying state for issue " 
		  . $issue->{'iid'} . "." ); 
	}
	 
	
	# Convert string dates to epoch seconds
	my $date_created = str2time($issue->{'created_at'});
	my $date_changed = str2time($issue->{'updated_at'});
	my $date_due = str2time($issue->{'due_date'});

	# Compute/set metrics on votes
	$total_upvotes += $issue->{'upvotes'};
	$total_downvotes += $issue->{'downvotes'};

	# Check if issue's due date has past
	if ( defined($date_due) and $date_due < $t_now->epoch and $issue->{'state'} =~ m!^open! ) { 
	    push( @issues_late, $issue ); 
	}

        # Check 1w, 1m, 1y for issues created, issues changed, and authors.
	if ( $date_created > $t_1w->epoch ) {
            $issues_created_1w++;
            if ( defined( $issue->{'author'} ) ) {
                $authors_1w{ $issue->{'author'}{'username'} }++;
            }            
        }

	if ( $date_created > $t_1m->epoch ) {
            $issues_created_1m++;
            if ( defined( $issue->{'author'} ) ) {
                $authors_1m{ $issue->{'author'}{'username'} }++;
            }            
        }

	if ( $date_created > $t_1y->epoch ) {
            $issues_created_1y++;
            if ( defined( $issue->{'author'} ) ) {
                $authors_1y{ $issue->{'author'}{'username'} }++;
            } 
        }

	$issues_changed_1w++ if ( $date_changed > $t_1w->epoch );
	$issues_changed_1m++ if ( $date_changed > $t_1m->epoch );
	$issues_changed_1y++ if ( $date_changed > $t_1y->epoch );

	# Track milestones information
	if ( defined( $issue->{'milestone'}{'id'} ) ) {
	    $milestones{ $issue->{'milestone'}{'id'} }{'def'} = $issue->{'milestone'};
	    $milestones{ $issue->{'milestone'}{'id'} }{'total'}++;
            if ( $issue->{'state'} =~ m!opened! ) {
                $milestones{ $issue->{'milestone'}{'id'} }{'opened'}++;
            } else {
                $milestones{ $issue->{'milestone'}{'id'} }{'closed'}++;
            }
	}

	# Gather people (i.e. all people who interact with the its) 
	# and authors (number of times each person has submitted an issue).
	if ( defined( $issue->{'author'} ) ) {
	    $people{$issue->{'author'}{'username'}}++;
	    $authors{$issue->{'author'}{'username'}}++;
	}
	if ( defined($issue->{'assignee'}) ) {
	    $people{$issue->{'assignee'}{'username'}}++;
	} else {
	    push( @issues_unassigned, $issue );
	    push( @issues_unassigned_open, $issue ) 
		if ($issue->{'state'} =~ m'^open'); 
	}
	push( @issues_f, \%issues_l );

	# Check if issue is old (not been updated for more than 1y) and open
	if ( ($date_changed < $t_1y->epoch)
	    && ($issue->{'state'} =~ m!^open!) ) {
	    push(@issues_open_old, $issue);
	}
	
        # Request information about notes for this specific issue.
# This has been commented because it takes too long. It works, however.
# Simple uncomment it to have it. You should also add some code to write it 
# to a CSV file if you'd like.
#        my $notes = $api->notes( $gl_id, 'issues', $issue->{'id'} );
#        foreach my $n (@$notes) {
#	    $people{ $n->{'author'}{'username'} }++;
#            push( @{$notes{ $issue->{'iid'} }}, $n );
#        }
        
	# Recommendations    
	if ( ($issue->{'state'} eq 'open') && ($date_changed < $t_1y->epoch) ) {
	    push( @{$ret{'recs'}}, { 'rid' => 'ITS_LONG_STANDING_OPEN', 
			   'severity' => 1,
			   'src' => 'GitLabIts',
			   'desc' => 'Issue ' . $issue->{'iid'} . ' has not been updated during the last year, '
			       . 'and is still open. Long-standing bugs have a negative impact on people\'s '
			       . 'perception. You should either close the bug or add some more information to '
			       . 'revive it.' 
		  } 
		);
	}
	
    }

    # Write our own list of issues.
    $repofs->write_output( $project_id, "gitlab_its_issues.json", encode_json(\@issues_f) );
    
    my $csv = Text::CSV->new({binary => 1, eol => "\n"});
    my @cols = ('id', 'state', 'title', 'web_url', 'created_at', 'updated_at', 
		'due_date', 'upvotes', 'downvotes', 'user_notes_count');
    my $csv_out = join(',', @cols) . "\n";
    
    foreach my $i (@issues_f) {
	my @issues = map { $i->{$_} } @cols;
	$csv->combine(@issues);
	$csv_out .= $csv->string();
    }
    
    $repofs->write_output($project_id, "gitlab_its_issues.csv", $csv_out);
        
    # Write our own list of late issues.
    $csv = Text::CSV->new({binary => 1, eol => "\n"});
    @cols = ('id', 'state', 'title', 'web_url', 'created_at', 'updated_at', 
		'due_date', 'upvotes', 'downvotes', 'user_notes_count');
    $csv_out = join(',', @cols) . "\n";
    foreach my $i (@issues_late) { 
	my @issues = map { $i->{$_} } @cols;
	$csv->combine(@issues);
	$csv_out .= $csv->string();
    }
    $repofs->write_output($project_id, "gitlab_its_issues_late.csv", $csv_out);
        
    # Write our own list of open, unassigned issues.
    $csv = Text::CSV->new({binary => 1, eol => "\n"});
    @cols = ('id', 'state', 'title', 'web_url', 'created_at', 'updated_at', 
		'due_date', 'upvotes', 'downvotes', 'user_notes_count');
    $csv_out = join(',', @cols) . "\n";
    foreach my $i (@issues_unassigned_open) { 
	my @issues = map { $i->{$_} } @cols;
	$csv->combine(@issues);
	$csv_out .= $csv->string();
    }
    $repofs->write_output($project_id, "gitlab_its_issues_unassigned_open.csv", $csv_out);
        
    # Write our own list of open issues.
    $csv = Text::CSV->new({binary => 1, eol => "\n"});
    @cols = ('id', 'state', 'title', 'web_url', 'created_at', 'updated_at', 
		'due_date', 'upvotes', 'downvotes', 'user_notes_count');
    $csv_out = join(',', @cols) . "\n";
    foreach my $i ( grep { $_->{'state'} eq 'opened' }  @issues_f) {
	my @issues = map { $i->{$_} } @cols;
	$csv->combine(@issues);
	$csv_out .= $csv->string();
    }    
    $repofs->write_output($project_id, "gitlab_its_issues_open.csv", $csv_out);
        
    # Write our own list of open old issues.
    $csv = Text::CSV->new({binary => 1, eol => "\n"});
    @cols = ('id', 'state', 'title', 'web_url', 'created_at', 'updated_at', 
		'due_date', 'upvotes', 'downvotes', 'user_notes_count');
    $csv_out = join(',', @cols) . "\n";
    foreach my $i ( @issues_open_old) {
	my @issues = map { $i->{$_} } @cols;
	$csv->combine(@issues);
	$csv_out .= $csv->string();
    }
    $repofs->write_output($project_id, "gitlab_its_issues_open_old.csv", $csv_out);
        
    # Write our own list of milestones (CSV).
    $csv = Text::CSV->new({binary => 1, eol => "\n"});
    @cols = ('iid', 'id', 'state', 'title', 'created_at', 'updated_at', 'start_date', 
             'due_date', 'description', 'issues_total', 'issues_opened', 'issues_closed');
    $csv_out = join(',', @cols) . "\n";
    foreach my $ms (keys %milestones) {
	my @ms = map { $milestones{$ms}{'def'}{$_} } @cols;
        $ms[-3] = $milestones{$ms}{'total'} || 0;
        $ms[-2] = $milestones{$ms}{'opened'} || 0;
        $ms[-1] = $milestones{$ms}{'closed'} || 0;

	$csv->combine(@ms);
	$csv_out .= $csv->string();
    }
    
    $repofs->write_output($project_id, "gitlab_its_milestones.csv", $csv_out);
            
    # Analyse retrieved data, generate info, metrics, plots and visualisation.
    $ret{'metrics'}{'ITS_OPEN'} = $issues_open;
    $ret{'metrics'}{'ITS_CLOSED'} = $issues_closed;
    $ret{'metrics'}{'ITS_ISSUES_ALL'} = $issues_vol;
    $ret{'metrics'}{'ITS_LATE'} = scalar @issues_late;
    $ret{'metrics'}{'ITS_UNASSIGNED'} = scalar @issues_unassigned;
    $ret{'metrics'}{'ITS_OPEN_UNASSIGNED'} = scalar @issues_unassigned_open;
    $ret{'metrics'}{'ITS_OPEN_OLD'} = scalar @issues_open_old;
    $ret{'metrics'}{'ITS_TOTAL_DOWNVOTES'} = $total_downvotes;
    $ret{'metrics'}{'ITS_TOTAL_UPVOTES'} = $total_upvotes;
    # time series
    $ret{'metrics'}{'ITS_CREATED_1W'} = $issues_created_1w;
    $ret{'metrics'}{'ITS_CREATED_1M'} = $issues_created_1m;
    $ret{'metrics'}{'ITS_CREATED_1Y'} = $issues_created_1y;
    $ret{'metrics'}{'ITS_UPDATED_1W'} = $issues_changed_1w;
    $ret{'metrics'}{'ITS_UPDATED_1M'} = $issues_changed_1m;
    $ret{'metrics'}{'ITS_UPDATED_1Y'} = $issues_changed_1y;
    $ret{'metrics'}{'ITS_AUTHORS'} = scalar keys %authors;
    $ret{'metrics'}{'ITS_AUTHORS_1W'} = scalar keys %authors_1w;
    $ret{'metrics'}{'ITS_AUTHORS_1M'} = scalar keys %authors_1m;
    $ret{'metrics'}{'ITS_AUTHORS_1Y'} = scalar keys %authors_1y;
    $ret{'metrics'}{'ITS_PEOPLE'} = scalar keys %people;

    # Write metrics csv file
    my @metrics_def = sort map { $conf{'provides_metrics'}{$_} } keys %{$conf{'provides_metrics'}};
    $csv_out = join(',', @metrics_def) . "\n";
    $csv_out
	.= join(',', map { $ret{'metrics'}{$_} } @metrics_def )
	. "\n";
    $repofs->write_output($project_id, "metrics_gitlab_its.csv", $csv_out);

    # Generate R report ###############################################

    # Now execute the main R script.
    push( @{$ret{'log'}}, "[Plugins::GitLabIts] Executing R main file." );
    my $r = Alambic::Tools::R->new();
    @{$ret{'log'}} = ( @{$ret{'log'}}, @{$r->knit_rmarkdown_inc( 
					     'GitLabIts', $project_id, 'gitlab_its.Rmd', [],
					     { "gitlab.url" => $gl_url, 
					       "gitlab.id" => $gl_id}
					     )} );
    
    
    push( @{$ret{'log'}}, "[Plugins::GitLabIts] GitLabIts execution finished." ); 
    
    return \%ret;    
}


1;
=encoding utf8

=head1 NAME

B<Alambic::Plugins::GitLabIts> - Retrieves issues tracking system information from a 
GitLab instance.

=head1 DESCRIPTION

B<Alambic::Plugins::GitLabIts> Retrieves issues tracking system information from a 
GitLab instance.

Parameters: 

=over

=item * gitlab_url The URL of the remote GitLab instance, e.g. https://www.gitlab.com.

=item * gitlab_id The ID used to identify the project in the GitLab forge, 
e.g. bbaldassari/Alambic.

=item * gitlab_token The private token used to access the gitlab instance. 
The private token must be generated by a user who has global rights on all 
analysed projects. It is generated, downloaded and reset from the user's 
account page (/profile/account).

=back

For the complete description of the plugin see the user documentation on the web site: L<https://alambic.io/Plugins/Pre/GitLabIts.html>.

=head1 SEE ALSO

L<https://alambic.io/Plugins/Pre/GitLabIts.html>,

L<Mojolicious>, L<http://alambic.io>, L<https://bitbucket.org/BorisBaldassari/alambic>


=cut

