package Alambic::Plugins::GitlabIts;

use strict; 
use warnings;

use Alambic::Model::RepoFS;

use Mojo::JSON qw( decode_json encode_json );
use Mojo::UserAgent;
use Data::Dumper;

# Main configuration hash for the plugin
my %conf = (
    "id" => "GitlabIts",
    "name" => "GitLab ITS",
    "desc" => [
	'qsf',
	'qsf',
    ],
    "type" => "pre",
    "ability" => [ 'metrics', 'data', 'recs', 'figs', 'viz' ],
    "params" => {
        "gitlab_url" => "The URL of the GitLab instance, e.g. http://mygitlab.mycompany.com.",
        "gitlab_id" => "The ID used to identify the project in the GitLab forge.",
        "gitlab_token" => "The private token used to access the gitlab instance. The private token must be generated by a user who has global rights on all analysed projects. It is generated, downlaoded and reset from the user's account page (/profile/account).",
    },
    "provides_cdata" => [
    ],
    "provides_info" => [
    ],
    "provides_data" => {
	"metrics_its_evol.csv" => "Evolution metrics for the ITS plugin (CSV).",
    },
    "provides_metrics" => {
        "CHANGED" => "ITS_CHANGED", 
    },
    "provides_figs" => {
        'its_evol_summary.rmd' => "its_evol_summary.html",
    },
    "provides_recs" => [
        "ITS_CLOSERS",
    ],
    "provides_viz" => {
        "gitlab_its.html" => "GitLab ITS",
    },
);


# Constructor
sub new {
    my ($class) = @_;
    
    return bless {}, $class;
}


sub get_conf() {
    return \%conf;
}


# Run plugin: retrieves data + compute_data 
sub run_plugin($$) {
    my ($self, $project_id, $conf) = @_;
    
    my %ret = (
	'metrics' => {},
	'info' => {},
	'recs' => [],
	'log' => [],
	);

    # Create RepoFS object for writing and reading files on FS.
    my $repofs = Alambic::Model::RepoFS->new();

    my $gl_url = $conf->{'gitlab_url'};
    my $gl_id = $conf->{'gitlab_id'};
    my $gl_token = $conf->{'gitlab_token'};
    my $gl_url_project = $gl_url . '/api/v3/projects/';
    my $gl_url_its = $gl_url . '/api/v3/projects/' . $gl_id . '/issues';

    # Fetch JSON data from GitLab server
    my $ua = Mojo::UserAgent->new;

    my $i = 1;
    my $project_its_res = $ua->get($gl_url_project => {"PRIVATE-TOKEN" => "$gl_token"})->res;

    # See Mojo::UserAgent doc: 
    # https://docs.gitlab.com/ee/api/README.html#pagination
    my $headers = $project_its_res->headers;
    my $headers_link = $headers->header('Link');
    print Dumper($headers_link);
    my $project_its = $project_its_res->body;
    
    my $project_json = encode_json($project_its);
    $repofs->write_input( $project_id, "import_gl_project.json", $project_json );
    $repofs->write_output( $project_id, "import_gl_project.json", $project_json );
    print "About to request '$gl_url_its'.\n";
    my $its_json = $ua->get($gl_url_its => {"PRIVATE-TOKEN" => "$gl_token"})->res->body;
    $repofs->write_input( $project_id, "import_gl_its.json", $its_json );
    $repofs->write_output( $project_id, "import_gl_its.json", $its_json );

    my $res_project = decode_json($project_json);
    my $res_its = decode_json($its_json);
    print Dumper($res_its);
    
    # Analyse retrieved data, generate info, metrics, plots and visualisation.
    $ret{'metrics'}{'star_count'} = $res_project->{'star_count'};
    $ret{'metrics'}{'forks_count'} = $res_project->{'forks_count'};
    $ret{'metrics'}{'forks_count'} = $res_project->{'forks_count'};


#    my $tmp_ret = &_compute_data( $project_id, $gl_url, $gl_id, $gl_token, $repofs );
        
    return \%ret;
}


# Basically read the imported files and make the mapping to the 
# new metric names.
sub _compute_data($$$) {
    my ($project_id, $project_pmi, $repofs) = @_;

    my @recs;
    my @log;
    
    push( @log, "[Plugins::EclipseIts] Starting compute data for [$project_id]." );

    my $metrics_new;

    # Read data from its file in $data_input
    my $json = $repofs->read_input( $project_id, "import_its.json" );
    my $metrics_old = decode_json($json);

    foreach my $metric (keys %{$metrics_old}) {
        if ( exists( $conf{'provides_metrics'}{uc($metric)} ) ) {
            $metrics_new->{ $conf{'provides_metrics'}{uc($metric)} } = $metrics_old->{$metric};
        }
    }
    
    # Write its metrics json file to disk.
    $repofs->write_output( $project_id, "metrics_its.json", encode_json($metrics_new) );

    # Write static metrics file
    my @metrics = sort map {$conf{'provides_metrics'}{$_}} keys %{$conf{'provides_metrics'}};
    my $csv_out = join( ',', sort @metrics) . "\n";
    $csv_out .= join( ',', map { $metrics_new->{$_} } sort @metrics) . "\n";
    
    $repofs->write_plugin( 'EclipseIts', $project_id . "_its.csv", $csv_out );
    $repofs->write_output( $project_id, "metrics_its.csv", $csv_out );
    
    # Read evol metrics file
    $json = $repofs->read_input( $project_id, "import_its_evol.json" );
    my $metrics_evol = decode_json($json);

    # Create csv data for evol
    $csv_out = "date,changed,changers,closed,closers,opened,openers,trackers,unixtime\n";
    foreach my $id ( 0 .. (scalar(@{$metrics_evol->{'date'}}) -1 ) ) {
	$csv_out .= $metrics_evol->{'date'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'changed'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'changers'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'closed'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'closers'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'opened'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'openers'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'trackers'}->[$id] . ',';
	$csv_out .= $metrics_evol->{'unixtime'}->[$id] . "\n";
    }
    $repofs->write_plugin( 'EclipseIts', $project_id . "_its_evol.csv", $csv_out );
    $repofs->write_output( $project_id, "metrics_its_evol.csv", $csv_out );

    # Now execute the main R script.
    push( @log, "[Plugins::EclipseIts] Executing R main file." );
    my $r = Alambic::Tools::R->new();
    @log = ( @log, @{$r->knit_rmarkdown_inc( 'EclipseIts', $project_id, 'eclipse_its.Rmd' )} );

    # And execute the figures R scripts.
    my @figs = grep( /.*\.rmd$/i, keys %{$conf{'provides_figs'}} );
    foreach my $fig (sort @figs) {
	push( @log, "[Plugins::EclipseIts] Executing R fig file [$fig]." );
	@log = ( @log, @{$r->knit_rmarkdown_html( 'EclipseIts', $project_id, $fig )} );
    }

    
    # Execute checks and fill recs.

    # Check number of open bugs.
    # If there are at least twice as many opened bugs as closed bugs, raise an alert.
    my $weeks = -4;

    #    print "#Metrics_vol " . Dumper($metrics_evol);
    my @closed = @{$metrics_evol->{'closed'}};
    my @opened = @{$metrics_evol->{'opened'}};
    
    my $closed_old = reduce { $a + $b } splice @closed, $weeks;
    my $opened_old = reduce { $a + $b } splice @opened, $weeks;

    if ( $closed_old < ( 2 * $opened_old) ) {
	push( @recs, { 'rid' => 'ITS_OPENED_BUGS', 
		       'severity' => 1,
		       'src' => 'EclipseIts',
		       'desc' => 'During last 4 weeks, there has been twice as many opened bugs (' 
			   . $opened_old . ') as closed bugs (' . $closed_old . '). This may be ok '
			   . 'if the activity has notably increased, but it could also reveal some '
			   . 'instability or decrease in project quality.' 
	      } 
	    );
    }
    
    # Check the number of closers.
    # If there are less closers than last year, raise an alert.
    if ($metrics_new->{'ITS_DIFF_NETCLOSERS_365'} < 0) {
	push( @recs, { 'rid' => 'ITS_CLOSERS', 
		       'severity' => 1,
		       'src' => 'EclipseIts',
		       'desc' => 'During past year, the number of people closing issues has '
			   . ' fallen by ' . $metrics_new->{'ITS_DIFF_NETCLOSERS_365'}
		           . '. This usually means a decrease in project diversity and activity.' 
	      } 
	    );
    }
    
    return {
	"metrics" => $metrics_new,
	"recs" => \@recs,
	"log" => \@log,
    };
}


1;
