package Alambic::Plugins::GitHubIts;

use strict; 
use warnings;

use Alambic::Model::RepoFS;
use Alambic::Tools::R;

use Net::GitHub;
use Mojo::JSON qw( decode_json encode_json );
use Date::Parse;
use Time::Piece;
use Time::Seconds;
use Text::CSV;
use Data::Dumper;

# Main configuration hash for the plugin
my %conf = (
    "id" => "GitHubIts",
    "name" => "GitHub Issues",
    "desc" => [
	'This plugin retrieves information about issues related to a project from a GitHub server.',
    ],
    "type" => "pre",
    "ability" => [ 'data', 'info', 'metrics', 'viz', 'users' ],
    "params" => {
        "github_url" => "The URL of the GitHub instance, e.g. http://mygithub.mycompany.com. Leave empty to use github.com",
        "github_user" => "The GitHub user the repository belongs to.",
        "github_repo" => "The GitHub repository to be analysed.",
        "github_token" => "The private token used to access the GitHub instance. The private token must be generated by a user who has global rights on the analysed projects. It is generated, downloaded and reset from the user's settings page (Developer settings). https://docs.github.com/en/free-pro-team/github/authenticating-to-github/creating-a-personal-access-token .",
    },
    "provides_cdata" => [
    ],
    "provides_info" => [
      "ITS_URL",
    ],
    "provides_data" => {
    	"import_github_issues.json" => "Original information provided on the repository (JSON).",

    	"github_issues.csv" => "List of all issues to the repository (CSV).",
    	"github_issues_open.csv" => "List of open issues to the repository (CSV).",

    	"metrics_github_issues.csv" => "All metrics computed by the Github ITS plugin (CSV).",
	    "metrics_github_issues.json" => "All metrics computed by the Github ITS plugin (JSON).",
	    "info_github_issues.csv" => "All information computed by the Github ITS plugin (CSV).",
    },
    "provides_metrics" => {
        "ITS_ISSUES_ALL"      => "ITS_ISSUES_ALL",
        "ITS_ISSUES_OPEN"            => "ITS_ISSUES_OPEN",
        "ITS_ISSUES_OPEN_UNASSIGNED" => "ITS_ISSUES_OPEN_UNASSIGNED",
        "ITS_ISSUES_OPEN_OLD"        => "ITS_ISSUES_OPEN_OLD",
        "ITS_AUTHORS"         => "ITS_AUTHORS",
        "ITS_AUTHORS_1W"      => "ITS_AUTHORS_1W",
        "ITS_AUTHORS_1M"      => "ITS_AUTHORS_1M",
        "ITS_AUTHORS_1Y"      => "ITS_AUTHORS_1Y",
        "ITS_CREATED_1W"      => "ITS_CREATED_1W",
        "ITS_CREATED_1M"      => "ITS_CREATED_1M",
        "ITS_CREATED_1Y"      => "ITS_CREATED_1Y",
        "ITS_UPDATED_1W"      => "ITS_UPDATED_1W",
        "ITS_UPDATED_1M"      => "ITS_UPDATED_1M",
        "ITS_UPDATED_1Y"      => "ITS_UPDATED_1Y",
        "ITS_ISSUES_OPEN_PERCENT"    => "ITS_ISSUES_OPEN_PERCENT",
    #    "ITS_LATE"            => "ITS_LATE",
        "ITS_DIVERSITY_RATIO_1Y" => "ITS_DIVERSITY_RATIO_1Y",
    },
    "provides_figs" => {
      'github_issues_authors_pie.html' => 'Pie chart of authors of issues in the repository.',
    },
    "provides_recs" => [
    ],
    "provides_viz" => {
        "github_issues.html" => "GitHub Issues",
    },
);


# Constructor
sub new {
    my ($class) = @_;
    
    return bless {}, $class;
}


sub get_conf() {
    return \%conf;
}


# Run plugin: retrieves data + compute_data 
sub run_plugin($$) {
    my ($self, $project_id, $conf) = @_;
    
    my %ret = (
	'metrics' => {},
	'info' => {},
	'recs' => [],
	'log' => [],
	);

    # Create RepoFS object for writing and reading files on FS.
    my $repofs = Alambic::Model::RepoFS->new();

    my $gh_url = $conf->{'github_url'} || 'https://api.github.com';
    my $gh_user = $conf->{'github_user'};
    my $gh_repo = $conf->{'github_repo'};
    my $gh_token = $conf->{'github_token'};

    # Time::Piece object. Will be used for the date calculations.
    my $t_now = localtime;
    my $t_1w  = $t_now - ONE_WEEK;
    my $t_1m  = $t_now - ONE_MONTH;
    my $t_1y  = $t_now - ONE_YEAR;

    push( @{$ret{'log'}}, "[Plugins::GitHubIts] Targeting data from [$gh_url] for project [$gh_user/$gh_repo]." ); 

    # Create Github API object for all rest operations.
    my $gh;
    if ($gh_token !~ m!^$!) { 
        push( @{$ret{'log'}}, "[Plugins::GitHubIts] Using access token." );
        $gh = Net::GitHub::V3->new(
          access_token => $gh_token,
          api_url => "$gh_url",
        );
    } else {
        push( @{$ret{'log'}}, "[Plugins::GitHubIts] Using anonymous access." );
        $gh = Net::GitHub::V3->new(
          api_url => "$gh_url",
        );
    }
    $gh->set_default_user_repo("$gh_user", "$gh_repo");


    # Issues ###############################################

    # Request general information about this project
    push( @{$ret{'log'}}, "[Plugins::GitHubIts] Retrieving Issues data." );
    my @issues;
    eval { @issues = $gh->issue->repos_issues( { state => 'all' } ); };
    if ($@) {
        push( @{$ret{'log'}}, "[Plugins::GitHubIts] ERROR: Failed to get data from server." );
        return \%ret;    
    }

    # Write project info to json file.
    $repofs->write_input($project_id, "import_github_issues.json",
			  encode_json(\@issues));

    # Get/Compute the metrics (mainly numbers, that usually evolve)
    my ($created_1w, $created_1m, $created_1y) = (0, 0, 0);
    my ($updated_1w, $updated_1m, $updated_1y) = (0, 0, 0);
    my (%authors, %authors_1w, %authors_1m, %authors_1y, %people);
    my (%components, %milestones, %versions);
    my (@open, @open_old, @unassigned_open);

    my $csv = Text::CSV->new({binary => 1, eol => "\n"});
    my @csv_header = ('id', 'summary', 'status', 'creator', 'assignee',
        'created_at', 'updated_at', 'labels', 'milestone', 'comments', 'url');
    my $csv_out = join( ',', @csv_header ) . "\n";
    my $csv_open_out = join( ',', @csv_header ) . "\n";
    
    # Initialise some metrics so they don't get undef when unset.
    $ret{'metrics'}{'ITS_ISSUES_ALL'} = scalar(@issues) || 0;
    $ret{'metrics'}{'ITS_ISSUES_OPEN'} = 0;
    $ret{'metrics'}{'ITS_ISSUES_OPEN_OLD'} = 0;
    $ret{'metrics'}{'ITS_ISSUES_OPEN_UNASSIGNED'} = 0;

    push( @{$ret{'log'}}, "[Plugins::GitHubIts] Parsing issues." );
    foreach my $issue (@issues) {

        # Convert string dates to epoch seconds      
        my $date_created
            = Time::Piece->strptime(int(str2time($issue->{'created_at'}) || 0), "%s");
        my $date_updated
            = Time::Piece->strptime(int(str2time($issue->{'updated_at'}) || 0), "%s");
        
        # Build list of label strings
        my $labels = join( '|', map { $_->{'name'} } @{$issue->{'labels'}} );

        # list milestones
        if ( defined($issue->{'milestone'}) ) {
            $milestones{ $issue->{'milestone'}{'title'} }++;
        }
      
        # Now manage time-related metrics and metadata (authors..)
        $authors{$issue->{'user'}{'login'}}++;

        # Is the issue recent (<1W)?
        if ($date_created > $t_1w->epoch) {
            $authors_1w{$issue->{'user'}{'login'}}++;
            $created_1w++;
        }
      
        # Is the issue recent (<1M)?
        if ($date_created > $t_1m->epoch) {
            $authors_1m{$issue->{'user'}{'login'}}++;
            $created_1m++;
        }
      
        # Is the issue recent (<1Y)?
        if ($date_created > $t_1y->epoch) {
            $authors_1y{$issue->{'user'}{'login'}}++;
            $created_1y++;
        }
      
        # Has the issue been updated recently (<1W)?
        if ($date_updated > $t_1w->epoch) { $updated_1w++; }
      
        # Has the issue been updated recently (<1M)?
        if ($date_updated > $t_1m->epoch) { $updated_1m++; }
      
        # Has the issue been updated recently (<1Y)?
        if ($date_updated > $t_1y->epoch) { 
            $updated_1y++; 
        } else {
            # Not updated for more than 1 year and still open?
            if ($issue->{'state'} =~ m!open!) {
                $ret{'metrics'}{'ITS_ISSUES_OPEN_OLD'}++;
            }
        }


        # Fill the full csv out in.
        $csv->combine( (
          $issue->{'number'},$issue->{'title'}, $issue->{'state'},
          $issue->{'user'}{'login'}, $issue->{'assignee'}{'login'},
          $issue->{'created_at'}, $issue->{'updated_at'}, $labels,
          $issue->{'milestone'}{'title'}, $issue->{'comments'}, $issue->{'html_url'}
        ) );
        $csv_out .= $csv->string();

        if ($issue->{'state'} =~ m!open!) {
            $ret{'metrics'}{'ITS_ISSUES_OPEN'}++;
            $csv_open_out .= $csv->string();
            if (not defined($issue->{'assignee'})) {
                $ret{'metrics'}{'ITS_ISSUES_OPEN_UNASSIGNED'}++;
            }
        }
    }

    $repofs->write_output($project_id, "github_issues.csv", $csv_out);
    $repofs->write_output($project_id, "github_issues_open.csv", $csv_open_out);

    push( @{$ret{'log'}}, "[Plugins::GitHubIts] Computing metrics." );

    my $all = $ret{'metrics'}{'ITS_ISSUES_ALL'} == 0 ? 1 : $ret{'metrics'}{'ITS_ISSUES_ALL'};
    $ret{'metrics'}{'ITS_ISSUES_OPEN_PERCENT'}
        = sprintf("%.0f", 100 * ($ret{'metrics'}{'ITS_ISSUES_OPEN'} / ($all)));
    $ret{'metrics'}{'ITS_AUTHORS'}         = scalar keys %authors;
    $ret{'metrics'}{'ITS_AUTHORS_1W'}      = scalar keys %authors_1w;
    $ret{'metrics'}{'ITS_AUTHORS_1M'}      = scalar keys %authors_1m;
    $ret{'metrics'}{'ITS_AUTHORS_1Y'}      = scalar keys %authors_1y;
    $ret{'metrics'}{'ITS_CREATED_1W'}      = $created_1w;
    $ret{'metrics'}{'ITS_CREATED_1M'}      = $created_1m;
    $ret{'metrics'}{'ITS_CREATED_1Y'}      = $created_1y;
    $ret{'metrics'}{'ITS_UPDATED_1W'}      = $updated_1w;
    $ret{'metrics'}{'ITS_UPDATED_1M'}      = $updated_1m;
    $ret{'metrics'}{'ITS_UPDATED_1Y'}      = $updated_1y;


    my $gh_web = $conf->{'github_url'} !~ m!^\s*$! ? $conf->{'github_url'} : 'https://github.com';
    $ret{'info'}{'ITS_URL'}      = $gh_web . '/' . $gh_user . '/' . $gh_repo . '/issues';
    
    # Metrics/Info  ###############################################

    # Write static metrics json file to disk.
    push( @{$ret{'log'}}, "[Plugins::GitHubIts] Writing metrics/info files to disk." );
    $repofs->write_output($project_id, "metrics_github_issues.json",
			  encode_json($ret{'metrics'}));

    # Write static metrics csv file to disk.
    my @metrics_def = sort map { $conf{'provides_metrics'}{$_} } keys %{$conf{'provides_metrics'}};
    $csv_out = join(',', @metrics_def) . "\n"; 
    my @values = map { $ret{'metrics'}{$_} } @metrics_def;
    $csv_out .= join(',', map { $_ || '0' } @values) . "\n";
    $repofs->write_output($project_id, "metrics_github_issues.csv", $csv_out);
    
    # Write info csv file to disk.
    my @info_def = sort @{$conf{'provides_info'}};
    $csv_out = join(',', @info_def) . "\n";
    my @info_values = map { $ret{'info'}{$_} || '' } @info_def; 
    $csv_out .= join(',', @info_values) . "\n";
    $repofs->write_output($project_id, "info_github_issues.csv", $csv_out);
    
    # Generate R report ###############################################

    # Now execute the main R script.
    push( @{$ret{'log'}}, "[Plugins::GitHubIts] Executing R main file." );
    my $r = Alambic::Tools::R->new();
    @{$ret{'log'}} = ( @{$ret{'log'}}, @{$r->knit_rmarkdown_inc( 
					     'GitHubIts', $project_id, 'github_issues.Rmd', [],
					     { "github.url" => $gh_url, 
					       "github.user" => $gh_user, 
					       "github.repo" => $gh_repo}
					     )} );

    # And execute the figures R scripts.
    my @figs = ('github_issues_authors_pie.rmd');
    foreach my $fig (sort @figs) { 
	push( @{$ret{'log'}}, "[Plugins::GitHubIts] Executing R fig file [$fig]." );
	@{$ret{'log'}} = ( @{$ret{'log'}}, @{$r->knit_rmarkdown_html( 'GitHubIts', $project_id, $fig )} );
    }

    return \%ret;    
}


1;

=encoding utf8

=head1 NAME

B<Alambic::Plugins::GitHubIts> - Retrieves a summary of data for a Github project, along with
SCM information (merge requests, commits, etc.).

=head1 DESCRIPTION

B<Alambic::Plugins::GitHubIts> - Retrieves a summary of data for a Github project, along with
SCM information (merge requests, commits, etc.).

Parameters: 

=over

=item * github_url The URL of the remote Github instance, e.g. https://www.github.com.

=item * github_id The ID used to identify the project in the Github forge, 
e.g. bbaldassari/Alambic.

=item * github_token The private token used to access the github instance. 
The private token must be generated by a user who has global rights on all 
analysed projects. It is generated, downloaded and reset from the user's 
account page (/profile/account).

=back

For the complete description of the plugin see the user documentation on the web site: L<https://alambic.io/Plugins/Pre/GitHubIts.html>.

=head1 SEE ALSO

L<https://alambic.io/Plugins/Pre/GitHubIts.html>,
L<https://github.com>,
L<Mojolicious>, L<http://alambic.io>, L<https://bitbucket.org/BorisBaldassari/alambic>


=cut
