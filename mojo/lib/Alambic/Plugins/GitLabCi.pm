package Alambic::Plugins::GitLabCi;

use strict; 
use warnings;

use Alambic::Model::RepoFS;

use GitLab::API::v3;
use Mojo::JSON qw( decode_json encode_json );
use Date::Parse;
use Time::Piece;
use Time::Seconds;
use Data::Dumper;

# Main configuration hash for the plugin
my %conf = (
    "id" => "GitLabCi",
    "name" => "GitLab CI",
    "desc" => [
	'Retrieves and analyses Continuous Integration data from a GitLab server. This plugin requires a token access that can be generated in the user settings.',
	'For more information on this plugin see the official documentation on the project web site: <a href=\"http://alambic.io/Plugins/Pre/GitLabCi.html\">http://alambic.io/Plugins/Pre/GitLabCi.html</a>.'
    ],
    "type" => "pre",
    "ability" => [ 'metrics', 'info', 'data', 'recs', 'figs', 'viz' ],
    "params" => {
        "gitlab_url" => "The URL of the GitLab instance, e.g. http://www.gitlab.com.",
        "gitlab_id" => "The ID used to identify the project in the GitLab forge, e.g. bbaldassari/Alambic.",
        "gitlab_token" => "The private token used to access the gitlab instance. The private token must be generated by a user who has global rights on all analysed projects. It is generated, downloaded and reset from the user's account page (/profile/account).",
    },
    "provides_cdata" => [
    ],
    "provides_info" => [
      "GL_CI_URL",
    ],
    "provides_data" => {
	"import_gitlab_ci_jobs.json" => "Original build file from GitLab server (JSON).",
	"gitlab_ci_jobs.csv" => "List of builds (CSV).",
	"gitlab_ci_jobs.json" => "List of builds (JSON).",
	"gitlab_ci_pipelines.csv" => "List of pipelines (CSV).",
	"gitlab_ci_pipelines.json" => "List of pipelines (JSON).",
    },
    "provides_metrics" => {
        "CI_BUILDS" => "CI_BUILDS", # Total number of builds (GL jobs)

	"CI_JOBS" => "CI_JOBS", # Total number of jobs (GL pipelines)
	"CI_JOBS_GREEN" => "CI_JOBS_GREEN",
	"CI_JOBS_RED" => "CI_JOBS_RED",
	"CI_JOBS_GREEN_RATIO" => "CI_JOBS_GREEN_RATIO",

	# JOBS_FAILED_1W => Last build is 'failed' for more than 1W
	"CI_JOBS_FAILED_1W" => "CI_JOBS_FAILED_1W",    

        "CI_BUILDS_SUCCESS" => "CI_BUILDS_SUCCESS", 
        "CI_BUILDS_SUCCESS_1W" => "CI_BUILDS_SUCCESS_1W", 
        "CI_BUILDS_SUCCESS_1M" => "CI_BUILDS_SUCCESS_1M", 

        "CI_BUILDS_FAILED" => "CI_BUILDS_FAILED", 
        "CI_BUILDS_FAILED_1W" => "CI_BUILDS_FAILED_1W", 
        "CI_BUILDS_FAILED_1M" => "CI_BUILDS_FAILED_1M", 
    },
    "provides_figs" => {
        'gitlabci_pie.rmd' => "gitlab_ci_pie.html",
    },
    "provides_recs" => [
        "CI_BUILDS_REC",
    ],
    "provides_viz" => {
        "gitlabci.html" => "GitLab CI",
    },
);


# Constructor
sub new {
    my ($class) = @_;
    
    return bless {}, $class;
}


sub get_conf() {
    return \%conf;
}


# Run plugin: retrieves data + compute_data 
sub run_plugin($$) {
    my ($self, $project_id, $conf) = @_;

    my @builds_ret;
    my %pipelines;
    my %ret = (
	'metrics' => {},
	'info' => {},
	'recs' => [],
	'log' => [],
	);
    
    # Create RepoFS object for writing and reading files on FS.
    my $repofs = Alambic::Model::RepoFS->new();

    my $gl_url = $conf->{'gitlab_url'};
    my $gl_id = $conf->{'gitlab_id'};
    my $gl_token = $conf->{'gitlab_token'};

    $ret{'info'}{'GL_CI_URL'} = $gl_url . '/' . $gl_id . '/pipelines';
    
    # Create GitLab API object for all rest operations.
    my $api = GitLab::API::v3->new(
        url   => $gl_url . "/api/v3",
        token => $gl_token,
	);

    # Time::Piece object. Will be used for the date calculations.
    my $t_now = localtime;
    my $t_1w = $t_now - ONE_WEEK;
    my $t_1m = $t_now - ONE_MONTH;
    
    # Retrieve information about all builds. Returns an array
    # of builds, see GitLab::API::v3 doc:
    # http://search.cpan.org/~bluefeet/GitLab-API-v3-1.00/lib/GitLab/API/v3.pm#BUILD_METHODS. 
    my $builds_p = $api->paginator( 'builds', $gl_id );
    my $builds;
    while (my $build = $builds_p->next()) {
        push( @$builds, $build );
    }
    
    # The API returns an array of builds.
    # A single build entry is as follows:
    # {
    # 	'stage' => 'test',
    # 	'runner' => {
    # 	    'is_shared' => $VAR1->[0]{'runner'}{'is_shared'},
    # 	    'active' => $VAR1->[0]{'runner'}{'is_shared'},
    # 	    'description' => 'shared-runners-manager-2.gitlab.com',
    # 	    'id' => 40788,
    # 	    'name' => 'gitlab-runner',
    # 	},
    # 	'tag' => $VAR1->[0]{'tag'},
    # 	'created_at' => '2017-01-13T20:49:27.221Z',
    # 	'commit' => {
    # 	    'committer_name' => 'Boris Baldassari',
    # 	    'author_email' => 'boris.baldassari@gmail.com',
    # 	    'created_at' => '2017-01-13T21:49:19.000+01:00',
    # 	    'message' => 'Test with gitlab ci.',
    # 	    'committed_date' => '2017-01-13T21:49:19.000+01:00',
    # 	    'authored_date' => '2017-01-13T21:49:19.000+01:00',
    # 	    'committer_email' => 'boris.baldassari@gmail.com',
    # 	    'author_name' => 'Boris Baldassari',
    # 	    'title' => 'Test with gitlab ci.',
    # 	    'short_id' => '3a0e48a7',
    # 	    'id' => '3a0e48a7c7bac84ede319291e47f9fde6a3420b8',
    # 	    'parent_ids' => [
    # 		'2c7a41905b2f0cc65d5d86d9aec7b23e3a909761'
    # 		],
    # 	},
    # 	'coverage' => undef,
    # 	'name' => 'rspec',
    # 	'id' => 8627602,
    # 	'finished_at' => '2017-01-13T20:51:00.436Z',
    # 	'user' => {
    # 	    'bio' => undef,
    # 	    'id' => 905787,
    # 	    'linkedin' => '',
    # 	    'name' => 'Boris Baldassari',
    # 	    'web_url' => 'https://gitlab.com/bbaldassari',
    # 	    'skype' => '',
    # 	    'location' => undef,
    # 	    'website_url' => '',
    # 	    'username' => 'bbaldassari',
    # 	    'organization' => undef,
    # 	    'twitter' => '',
    # 	    'state' => 'active',
    # 	    'avatar_url' => 'https://secure.gravatar.com/avatar/7c25f6ef0ebf87fc0cb394864d32de33?s=80&d=identicon',
    # 	    'created_at' => '2016-12-20T17:22:34.199Z'
    #     },
    # 	'status' => 'failed',
    # 	'pipeline' => {
    # 	    'sha' => '3a0e48a7c7bac84ede319291e47f9fde6a3420b8',
    # 	    'id' => 5814055,
    # 	    'ref' => 'master',
    # 	    'status' => 'failed'
    #     },
    # 	'started_at' => '2017-01-13T20:49:32.302Z',
    #     'ref' => 'master'
    # }


    
    if ( ref($builds) eq "ARRAY" ) {
	push( @{$ret{'log'}}, "[Plugins::GitLabCi] Retrieved build info from [$gl_url].");
#	print "JSON " . Dumper($builds);
	# Store all build info in a hash for the
	# csv and json extract.
	foreach my $build (@$builds) {
	    my %build_ret;
	    $build_ret{'id'} = $build->{'id'};
	    $build_ret{'ref_branch'} = $build->{'ref'};
	    $build_ret{'started_at'} = $build->{'started_at'};
	    $build_ret{'finished_at'} = $build->{'finished_at'};
	    $build_ret{'status'} = $build->{'status'};
	    $build_ret{'stage'} = $build->{'stage'};
	    $build_ret{'commit_id'} = $build->{'commit'}->{'id'};
	    $build_ret{'commit_committer_name'} = $build->{'commit'}->{'committer_name'};
	    
	    my $p_id = $build->{'pipeline'}{'id'};
	    $build_ret{'pipeline_id'} = $p_id;

	    # Copy pipeline info from build item.
	    $pipelines{ $p_id }->{'ref'} = $build->{'pipeline'}{'ref'};
	    $pipelines{ $p_id }->{'sha'} = $build->{'pipeline'}{'sha'};
	    $pipelines{ $p_id }->{'status'} = $build->{'pipeline'}{'status'};

	    $pipelines{ $p_id }->{'builds'}++;
	    $pipelines{ $p_id }->{'builds_success'}++ 
		if ( $build->{'status'} eq 'success' );

	    my $date_started = str2time($build->{'started_at'});

	    # If build is more recent than what is stored, then replace it.
	    if ( (not exists($pipelines{ $p_id }->{'last_build_time'})) || 
		 $date_started >= $pipelines{ $p_id }->{'last_build_time'} ) {
		$pipelines{ $p_id }->{'last_build_id'} = $build->{'id'};
		$pipelines{ $p_id }->{'last_build_time'} = $date_started;
	    } 
	    
	    # Extract successful and failed pipelines.
	    my $pl_all = scalar keys %pipelines;
	    my @pl_success = grep $pipelines{$_}->{'status'} eq 'success', keys %pipelines;
	    my @pl_failed = grep $pipelines{$_}->{'status'} eq 'failed', keys %pipelines;
	    my @pl_failed_1w = grep $pipelines{$_}->{'last_build_time'} > $t_1w->epoch, @pl_failed;
	    
	    $ret{'metrics'}{'CI_JOBS'} = $pl_all;
	    $ret{'metrics'}{'CI_JOBS_GREEN'} = scalar(@pl_success);
	    $ret{'metrics'}{'CI_JOBS_RED'} = scalar(@pl_failed);
	    $ret{'metrics'}{'CI_JOBS_FAILED_1W'} = scalar(@pl_failed_1w);

	    # Compute GREEN RATIO
	    $ret{'metrics'}{'CI_JOBS_GREEN_RATIO'} = int(100 * scalar(@pl_success) / $pl_all);	    

	    if ( $date_started > $t_1w->epoch ) {
		if ( $build->{'status'} eq 'success' ) {
		    $ret{'metrics'}{'CI_BUILDS_SUCCESS_1W'}++;
		} elsif ( $build->{'status'} eq 'failed' ) {
		    $ret{'metrics'}{'CI_BUILDS_FAILED_1W'}++;
		}
	    }

	    if ( $date_started > $t_1m->epoch ) {
		if ( $build->{'status'} eq 'success' ) {
		    $ret{'metrics'}{'CI_BUILDS_SUCCESS_1M'}++;
		} elsif ( $build->{'status'} eq 'failed' ) {
		    $ret{'metrics'}{'CI_BUILDS_FAILED_1M'}++;
		}
	    }
	    
	    push( @builds_ret, \%build_ret );

	}

	# Extract successful and failed builds.
	my @builds_success = grep $_->{'status'} eq 'success', @$builds;
	my @builds_failed = grep $_->{'status'} eq 'failed', @$builds;

	# Set metrics
	$ret{'metrics'}{'CI_BUILDS'} = scalar(@$builds);
	$ret{'metrics'}{'CI_JOBS'} = scalar(keys %pipelines);
	$ret{'metrics'}{'CI_BUILDS_FAILED'} = scalar(@builds_failed);
	$ret{'metrics'}{'CI_BUILDS_SUCCESS'} = scalar(@builds_success);
    } else {
	# Happens when no CI is defined on the project.
	push( @{$ret{'log'}}, "Error: builds is not an array. No CI defined on the project.");
	return \%ret;
    }
    
    # Write ci builds json file to disk.
    $repofs->write_input( $project_id, "import_ci_jobs.json", encode_json($builds) );
    $repofs->write_output( $project_id, "gitlab_ci_jobs.json", encode_json(\@builds_ret) );

    # Write ci pipelines json file to disk.
    $repofs->write_output( $project_id, "gitlab_ci_pipelines.json", encode_json(\%pipelines) );

    # Write CI metrics to CSV files.
    my @ci_metrics_csv;
    push( @ci_metrics_csv, "CI_BUILDS,CI_JOBS,CI_JOBS_GREEN,CI_JOBS_RED,CI_BUILDS_SUCCESS,"
	  . "CI_BUILDS_SUCCESS_1W,CI_BUILDS_SUCCESS_1M,CI_BUILDS_FAILED," 
	  . "CI_BUILDS_FAILED_1W,CI_BUILDS_FAILED_1M\n" );
    push( @ci_metrics_csv, "" . ($ret{'metrics'}{'CI_BUILDS'} || 0) . ","
	  . ($ret{'metrics'}{'CI_JOBS'} || 0) . ","
	  . ($ret{'metrics'}{'CI_JOBS_GREEN'} || 0) . ","
	  . ($ret{'metrics'}{'CI_JOBS_RED'} || 0) . ","
	  . ($ret{'metrics'}{'CI_BUILDS_SUCCESS'} || 0) . ","
	  . ($ret{'metrics'}{'CI_BUILDS_SUCCESS_1W'} || 0) . ","
	  . ($ret{'metrics'}{'CI_BUILDS_SUCCESS_1M'} || 0) . ","
	  . ($ret{'metrics'}{'CI_BUILDS_FAILED'} || 0) . ","
	  . ($ret{'metrics'}{'CI_BUILDS_FAILED_1W'} || 0) . ","
	  . ($ret{'metrics'}{'CI_BUILDS_FAILED_1M'} || 0) . "\n" );
    $repofs->write_plugin( 'GitLabCi', $project_id . "_ci_metrics.csv", join("", @ci_metrics_csv) );
    $repofs->write_output( $project_id, "ci_metrics.csv", join("", @ci_metrics_csv) );
				       
    # Convert builds info to csv
    my @jobs_csv;
    push( @jobs_csv, "id,status,ref_branch,started_at,finished_at,stage,commit_id,"
	  . "commit_committer_name,pipeline_id\n" );
    foreach my $build (@builds_ret) {
	my $csv_out = $build->{'id'} . ',' . $build->{'status'} . ',' 
	    . $build->{'ref_branch'} . ',' . $build->{'started_at'} . ',' 
	    . $build->{'finished_at'} . ',' . $build->{'stage'} . ',' 
	    . $build->{'commit_id'} . ',' . $build->{'commit_committer_name'} . ',' 
	    . $build->{'pipeline_id'} . "\n";
	push( @jobs_csv, $csv_out );
    }
    $repofs->write_plugin( 'GitLabCi', $project_id . "_ci_jobs.csv", join("", @jobs_csv) );
    $repofs->write_output( $project_id, "ci_jobs.csv", join("", @jobs_csv) );

    # Convert pipelines info to csv
    my @pipelines_csv;
    push( @pipelines_csv, "id,sha,ref,status,builds,builds_success,last_build_id,last_build_time\n" );
    foreach my $pipeline (keys %pipelines) {
	my $csv_out = $pipeline . ',' 
	    . ($pipelines{$pipeline}->{'sha'} || "") . ',' 
	    . ($pipelines{$pipeline}->{'ref'} || "") . ',' 
	    . ($pipelines{$pipeline}->{'status'} || "") . ',' 
	    . ($pipelines{$pipeline}->{'builds'} || "") . ',' 
	    . ($pipelines{$pipeline}->{'builds_success'} || "") . ',' 
	    . ($pipelines{$pipeline}->{'last_build_id'} || "") . ',' 
	    . ($pipelines{$pipeline}->{'last_build_time'} || "") . "\n";
	push( @pipelines_csv, $csv_out );
    }
    $repofs->write_plugin( 'GitLabCi', $project_id . "_ci_pipelines.csv", join("", @pipelines_csv) );
    $repofs->write_output( $project_id, "ci_pipelines.csv", join("", @pipelines_csv) );

    # Recommendations    
    # if ( ($issue->{'state'} eq 'open') && ($date_changed < $t_1y->epoch) ) {
    # 	push( 
    # 	    @{$ret{'recs'}}, 
    # 	    { 'rid' => 'CI_BUILDS_', 
    # 	      'severity' => 1,
    # 	      'src' => 'GitLabIts',
    # 	      'desc' => 'Issue ' . $issue->{'iid'} . ' has not been updated during the last year, '
    # 		  . 'and is still open. Long-standing bugs have a negative impact on people\'s '
    # 		  . 'perception. You should either close the bug or add some more information.' 
    # 	    } 
    # 	    );
    # }
    
    # Generate R report

    # Now execute the main R script.
    push( @{$ret{'log'}}, "[Plugins::GitLabCi] Executing R main file." );
    my $r = Alambic::Tools::R->new();
    @{$ret{'log'}} = ( @{$ret{'log'}}, @{$r->knit_rmarkdown_inc( 
					     'GitLabCi', $project_id, 'gitlabci.Rmd',
					     { "gitlab.url" => $gl_url, 
					       "gitlab.id" => $gl_id}
					     )} );
    
    # And execute the figures R scripts.
    my @figs = grep( /.*\.rmd$/i, keys %{$conf{'provides_figs'}} );
    foreach my $fig (sort @figs) {
	push( @{$ret{'log'}}, "[Plugins::GitLabCi] Executing R fig file [$fig]." );
	@{$ret{'log'}} = ( @{$ret{'log'}}, @{$r->knit_rmarkdown_html( 'GitLabCi', $project_id, $fig )} );
    }
    
    return \%ret;
}

1;



1;
=encoding utf8

=head1 NAME

B<Alambic::Plugins::GitLabCi> - Retrieves Continuous Integration information from a 
GitLab instance.

=head1 DESCRIPTION

B<Alambic::Plugins::GitLabCi> - Retrieves Continuous Integration information from a 
GitLab instance.

Parameters: 

=over

=item * gitlab_url The URL of the remote GitLab instance, e.g. https://www.gitlab.com.

=item * gitlab_id The ID used to identify the project in the GitLab forge, 
e.g. bbaldassari/Alambic.

=item * gitlab_token The private token used to access the gitlab instance. 
The private token must be generated by a user who has global rights on all 
analysed projects. It is generated, downloaded and reset from the user's 
account page (/profile/account).

=back

For the complete description of the plugin see the user documentation on the web site: L<https://alambic.io/Plugins/Pre/GitLabCi.html>.

=head1 SEE ALSO

L<https://alambic.io/Plugins/Pre/GitLabCi.html>,

L<Mojolicious>, L<http://alambic.io>, L<https://bitbucket.org/BorisBaldassari/alambic>


=cut
