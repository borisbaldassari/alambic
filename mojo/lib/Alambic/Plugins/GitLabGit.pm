package Alambic::Plugins::GitLabGit;

use strict; 
use warnings;

use Alambic::Model::RepoFS;
use Alambic::Tools::R;

use GitLab::API::v3;
use Mojo::JSON qw( decode_json encode_json );
use Date::Parse;
use Time::Piece;
use Time::Seconds;
use Text::CSV;
use Data::Dumper;

# Main configuration hash for the plugin
my %conf = (
    "id" => "GitLabGit",
    "name" => "GitLab Git",
    "desc" => [
	'Retrieves and analyses Continuous Integration data from a GitLab server. This plugin requires a token access that can be generated in the user settings.',
	'For more information on this plugin see the official documentation on the project web site: <a href=\"http://alambic.io/Plugins/Pre/GitLabGit.html\">http://alambic.io/Plugins/Pre/GitLabGit.html</a>.'
    ],
    "type" => "pre",
    "ability" => [ 'metrics', 'info', 'data', 'recs', 'figs', 'viz' ],
    "params" => {
        "gitlab_url" => "The URL of the GitLab instance, e.g. http://www.gitlab.com.",
        "gitlab_id" => "The ID used to identify the project in the GitLab forge, e.g. bbaldassari/Alambic.",
        "gitlab_token" => "The private token used to access the gitlab instance. The private token must be generated by a user who has global rights on all analysed projects. It is generated, downloaded and reset from the user's account page (/profile/account).",
    },
    "provides_cdata" => [
    ],
    "provides_info" => [
      "GL_MRS_URL",
      "GL_COMMITS_URL",
    ],
    "provides_data" => {
	"import_gitlab_git_commits.json" => "Original build file from GitLab server (JSON).",
	"import_gitlab_git_merge_requests.json" => "Original build file from GitLab server (JSON).",
	"gitlab_git_merge_requests.csv" => "List of merge requests (CSV).",
	"gitlab_git_merge_requests.json" => "List of merge requests (JSON).",
	"gitlab_git_commits.csv" => "List of commits (CSV).",
	"gitlab_git_commits.json" => "List of commits (JSON).",
	"gitlab_git_commits_hist.csv" => "Evolution of commits, sorted by date (CSV).",
    },
    "provides_metrics" => {
	"SCM_AUTHORS"       => "SCM_AUTHORS",
	"SCM_AUTHORS_1W"    => "SCM_AUTHORS_1W",
	"SCM_AUTHORS_1M"    => "SCM_AUTHORS_1M",
	"SCM_AUTHORS_1Y"    => "SCM_AUTHORS_1Y",
	"SCM_COMMITS"       => "SCM_COMMITS",
	"SCM_COMMITS_1W"    => "SCM_COMMITS_1W",
	"SCM_COMMITS_1M"    => "SCM_COMMITS_1M",
	"SCM_COMMITS_1Y"    => "SCM_COMMITS_1Y",
	"SCM_COMMITTERS"    => "SCM_COMMITTERS",
	"SCM_COMMITTERS_1W" => "SCM_COMMITTERS_1W",
	"SCM_COMMITTERS_1M" => "SCM_COMMITTERS_1M",
	"SCM_COMMITTERS_1Y" => "SCM_COMMITTERS_1Y",
	"SCM_MRS"           => "SCM_MRS",
	"SCM_MRS_OPENED"    => "SCM_MRS_OPENED",
	"SCM_MRS_OPENED_1W"    => "SCM_MRS_OPENED_1W",
	"SCM_MRS_OPENED_1M"    => "SCM_MRS_OPENED_1M",
	"SCM_MRS_OPENED_1Y"    => "SCM_MRS_OPENED_1Y",
	"SCM_MRS_OPENED_STILL_1W"    => "SCM_MRS_OPENED_STILL_1W",
	"SCM_MRS_OPENED_STILL_1M"    => "SCM_MRS_OPENED_STILL_1M",
	"SCM_MRS_OPENED_STILL_1Y"    => "SCM_MRS_OPENED_STILL_1Y",
	"SCM_MRS_OPENED_STALED_1M" => "SCM_MRS_OPENED_STALED_1M",
	"SCM_MRS_CLOSED"    => "SCM_MRS_CLOSED",
	"SCM_MRS_MERGED"    => "SCM_MRS_MERGED",
    },
    "provides_figs" => {
#        'gitlabgit_pie.rmd' => "gitlab_ci_pie.html",
    },
    "provides_recs" => [
        "SCM_MRS_STALED_1W",
        "SCM_LOW_ACTIVITY",
        "SCM_ZERO_ACTIVITY",
        "SCM_LOW_DIVERSITY",
    ],
    "provides_viz" => {
        "gitlabgit.html" => "GitLab Git",
    },
);


# Constructor
sub new {
    my ($class) = @_;
    
    return bless {}, $class;
}


sub get_conf() {
    return \%conf;
}


# Run plugin: retrieves data + compute_data 
sub run_plugin($$) {
    my ($self, $project_id, $conf) = @_;

    my %ret = (
	'metrics' => {},
	'info' => {},
	'recs' => [],
	'log' => [],
	);
    
    # Create RepoFS object for writing and reading files on FS.
    my $repofs = Alambic::Model::RepoFS->new();

    my $gl_url = $conf->{'gitlab_url'};
    my $gl_id = $conf->{'gitlab_id'};
    my $gl_token = $conf->{'gitlab_token'};

    $ret{'info'}{'GL_MRS_URL'} = $gl_url . '/' . $gl_id . '/merge_requests';
    $ret{'info'}{'GL_COMMITS_URL'} = $gl_url . '/' . $gl_id . '/commits/master';

    # Create GitLab API object for all rest operations.
    my $api = GitLab::API::v3->new(
        url   => $gl_url . "/api/v3",
        token => $gl_token,
	);

    # Time::Piece object. Will be used for the date calculations.
    my $t_now = localtime;
    my $t_1w = $t_now - ONE_WEEK;
    my $t_1m = $t_now - ONE_MONTH;
    my $t_1y = $t_now - ONE_YEAR;
    
    # Commits ###############################################

    # Retrieve information about all merge requests. Returns an array
    # of mrs, see GitLab::API::v3 doc:
    # https://metacpan.org/pod/GitLab::API::v3#MERGE-REQUEST-METHODS
    my $commits_p = $api->paginator( 'commits', $gl_id );
    my $commits;
    while (my $commit = $commits_p->next()) {
        push( @$commits, $commit );
    }
    
    my @commits_ret;
    my (%authors, %authors_1w, %authors_1m, %authors_1y);
    my %users;
    my (%committers, %committers_1w, %committers_1m, %committers_1y);
    my %timeline_c;
    my %timeline_a;
    
    # Initialise some zero values for some metrics -- others are set to zero anyway.
    $ret{'metrics'}{'SCM_COMMITS'}    = 0;
    $ret{'metrics'}{'SCM_COMMITS_1W'} = 0;
    $ret{'metrics'}{'SCM_COMMITS_1M'} = 0;
    $ret{'metrics'}{'SCM_COMMITS_1Y'} = 0;

    # The API returns an array of merge requests.
    if ( ref($commits) eq "ARRAY" ) {
 	push(@{$ret{'log'}}, "[Plugins::GitLabGit] Retrieved Commits info from [$gl_url].");
 	# Store all merge request info in a hash for the
 	# csv and json extract.
 	foreach my $commit (@$commits) {

	    # Store information we need about commits
 	    my %mycommit; 
 	    $mycommit{'id'} = $commit->{'id'};
 	    $mycommit{'title'} = $commit->{'title'};
 	    $mycommit{'message'} = $commit->{'message'};
 	    $mycommit{'author_email'} = $commit->{'author_email'};
 	    $mycommit{'author_name'} = $commit->{'author_name'};
 	    $mycommit{'committer_email'} = $commit->{'committer_email'};
 	    $mycommit{'committer_name'} = $commit->{'committer_name'};
 	    $mycommit{'committed_date'} = str2time( $commit->{'committed_date'} );
 	    $mycommit{'authored_date'} = str2time( $commit->{'authored_date'} );

	    # Build timeline (commits sorted by date)
	    my $date = Time::Piece->strptime($mycommit{'committed_date'} || 0, "%s");
	    my $date_m = $date->strftime("%Y-%m-%d");
	    $timeline_c{$date_m}++;

	    # Build users file, populate authors data
	    if (defined($commit->{'author_email'})) {
		$authors{$commit->{'author_email'}}++;
		my $event = {
		    "type" => "commit",
		    "id"   => $commit->{'id'},
		    "time" => $commit->{'committed_date'},
		    "msg"  => $commit->{'message'}
		};
		push(@{$users{$commit->{'author_email'}}}, $event);
		$timeline_a{$date_m}{$commit->{'author_email'}}++;
	    }
	    # Populate committers data
	    if (defined($commit->{'committer_email'})) {
		$committers{$commit->{'committer_email'}}++;
	    }
	    
	    # Is the commit recent (<1W)?
	    if ($date > $t_1w->epoch) {
		$ret{'metrics'}{'SCM_COMMITS_1W'}++;
		if (defined($commit->{'author_email'})) {
		    $authors_1w{$commit->{'author_email'}}++;
		}
		if (defined($commit->{'committer_email'})) {
		    $committers_1w{$commit->{'committer_email'}}++;
		}
	    }
	    
	    # Is the commit recent (<1M)?
	    if ($date > $t_1m->epoch) {
		$ret{'metrics'}{'SCM_COMMITS_1M'}++;
		if (defined($commit->{'author_email'})) {
		    $authors_1m{$commit->{'author_email'}}++;
		}
		if (defined($commit->{'committer_email'})) {
		    $committers_1m{$commit->{'committer_email'}}++;
		}
	    }
	    
	    # Is the commit recent (<1Y)?
	    if ($date > $t_1y->epoch) {
		$ret{'metrics'}{'SCM_COMMITS_1Y'}++;
		if (defined($commit->{'author_email'})) {
		    $authors_1y{$commit->{'author_email'}}++;
		}
		if (defined($commit->{'committer_email'})) {
		    $committers_1y{$commit->{'committer_email'}}++;
		}
	    }
	    
	    push( @commits_ret, \%mycommit );
 	}
	
     	# Set metrics
     	$ret{'metrics'}{'SCM_COMMITS'} = scalar(@commits_ret);

     	$ret{'metrics'}{'SCM_AUTHORS'} = scalar(keys %authors);
     	$ret{'metrics'}{'SCM_AUTHORS_1W'} = scalar(keys %authors_1w);
     	$ret{'metrics'}{'SCM_AUTHORS_1M'} = scalar(keys %authors_1m);
     	$ret{'metrics'}{'SCM_AUTHORS_1Y'} = scalar(keys %authors_1y);
	
     	$ret{'metrics'}{'SCM_COMMITTERS'} = scalar(keys %committers);
     	$ret{'metrics'}{'SCM_COMMITTERS_1W'} = scalar(keys %committers_1w);
     	$ret{'metrics'}{'SCM_COMMITTERS_1M'} = scalar(keys %committers_1m);
     	$ret{'metrics'}{'SCM_COMMITTERS_1Y'} = scalar(keys %committers_1y);
     } else {
     	# Happens when no git repo is defined on the project.
     	push( @{$ret{'log'}}, "Error: merge_requests is not an array.");
     	return \%ret;
     }    
    
    # Write commits json files to disk.
    $repofs->write_input( $project_id, "import_gitlab_git_commits.json", encode_json($commits) );
    $repofs->write_output( $project_id, "gitlab_git_commits.json", encode_json(\@commits_ret) );

    # Write list of commits to the disk, csv.
    my $csv = Text::CSV->new({binary => 1, eol => "\n"});
    my @cols = ('id', 'title', 'message', 'committed_date', 'authored_date', 
		'author_email', 'author_name', 'committer_email', 'committer_name');
    my $csv_out = join(',', @cols) . "\n";
    foreach my $c (@commits_ret) {
        my @cs = map { $c->{$_} } @cols;
        $csv->combine(@cs);
        $csv_out .= $csv->string();
    }    
    $repofs->write_output($project_id, "gitlab_git_commits.csv", $csv_out);

    
    # Write commits history csv file to disk.
    my %timelines = (%timeline_a, %timeline_c);
    my @timeline
	= map { $_ . "," . $timeline_c{$_} . "," . scalar(keys %{$timeline_a{$_}}) }
    sort keys %timelines;
    $csv_out = "date,commits,authors\n";
    $csv_out .= join("\n", @timeline) . "\n";
    $repofs->write_output($project_id, "gitlab_git_commits_hist.csv", $csv_out);

    # Merge requests ###############################################

    # Retrieve information about all merge requests. Returns an array
    # of mrs, see GitLab::API::v3 doc:
    # https://metacpan.org/pod/GitLab::API::v3#MERGE-REQUEST-METHODS
    my $mrs_p = $api->paginator( 'merge_requests', $gl_id );
    my $mrs;
    while (my $mr = $mrs_p->next()) {
        push( @$mrs, $mr );
    }
    
    my @mrs_ret;
    
    # The API returns an array of merge requests.
    if ( ref($mrs) eq "ARRAY" ) {
 	push( @{$ret{'log'}}, "[Plugins::GitLabGit] Retrieved Merge requests info from [$gl_url].");
 	# Store all merge request info in a hash for the
 	# csv and json extract.
 	foreach my $mr (@$mrs) {
 	    my %mymr;
 	    $mymr{'id'} = $mr->{'iid'};
 	    $mymr{'title'} = $mr->{'title'};
 	    $mymr{'state'} = $mr->{'state'};
 	    $mymr{'description'} = $mr->{'description'};
 	    $mymr{'assignee'} = $mr->{'assignee'};
 	    $mymr{'web_url'} = $mr->{'web_url'};
 	    $mymr{'labels'} = $mr->{'labels'};
 	    $mymr{'merge_status'} = $mr->{'merge_status'};
 	    $mymr{'source_project_id'} = $mr->{'source_project_id'};
 	    $mymr{'source_branch'} = $mr->{'source_branch'};
 	    $mymr{'target_project_id'} = $mr->{'target_project_id'};
 	    $mymr{'target_branch'} = $mr->{'target_branch'};
 	    $mymr{'upvotes'} = $mr->{'upvotes'};
 	    $mymr{'downvotes'} = $mr->{'downvotes'};
 	    $mymr{'user_notes_count'} = $mr->{'user_notes_count'};
 	    $mymr{'milestone'} = $mr->{'milestone'}{'title'} || undef;
 	    $mymr{'author'} = $mr->{'author'}{'username'} || undef; # could be 'name', too.
 	    $mymr{'created_at'} = str2time( $mr->{'created_at'} );
 	    $mymr{'updated_at'} = str2time( $mr->{'updated_at'} );

	    push( @mrs_ret, \%mymr );
 	}

	# Extract successful and failed builds.
	my @mrs_opened = grep $_->{'state'} =~ m'opened', @$mrs;
     	my @mrs_merged = grep $_->{'state'} =~ m'merged', @$mrs;
     	my @mrs_closed = grep $_->{'state'} =~ m'closed', @$mrs;
	
     	my @mrs_opened_1w = grep $_->{'created_at'} < $t_1w, @$mrs;
     	my @mrs_opened_1m = grep $_->{'created_at'} < $t_1m, @$mrs;
     	my @mrs_opened_1y = grep $_->{'created_at'} < $t_1y, @$mrs;
     	my @mrs_opened_still_1w = grep $_->{'state'} =~ m'opened' && $_->{'created_at'} < $t_1w, @$mrs;
     	my @mrs_opened_still_1m = grep $_->{'state'} =~ m'opened' && $_->{'created_at'} < $t_1m, @$mrs;
     	my @mrs_opened_still_1y = grep $_->{'state'} =~ m'opened' && $_->{'created_at'} < $t_1y, @$mrs;
     	my @mrs_opened_staled_1m = grep $_->{'state'} =~ m'opened' && $_->{'updated_at'} < $t_1m, @$mrs;
	
     	# Set metrics
     	$ret{'metrics'}{'SCM_MRS'} = scalar(@$mrs);
     	$ret{'metrics'}{'SCM_MRS_OPENED'} = scalar(@mrs_opened);
     	$ret{'metrics'}{'SCM_MRS_OPENED_1W'} = scalar(@mrs_opened_1w);
     	$ret{'metrics'}{'SCM_MRS_OPENED_1M'} = scalar(@mrs_opened_1m);
     	$ret{'metrics'}{'SCM_MRS_OPENED_1Y'} = scalar(@mrs_opened_1y);
     	$ret{'metrics'}{'SCM_MRS_OPENED_STILL_1W'} = scalar(@mrs_opened_still_1w);
     	$ret{'metrics'}{'SCM_MRS_OPENED_STILL_1M'} = scalar(@mrs_opened_still_1m);
     	$ret{'metrics'}{'SCM_MRS_OPENED_STILL_1Y'} = scalar(@mrs_opened_still_1y);
     	$ret{'metrics'}{'SCM_MRS_OPENED_STALED_1M'} = scalar(@mrs_opened_staled_1m);
     	$ret{'metrics'}{'SCM_MRS_MERGED'} = scalar(@mrs_merged);
     	$ret{'metrics'}{'SCM_MRS_CLOSED'} = scalar(@mrs_closed);

     } else {
     	# Happens when no git repo is defined on the project.
     	push( @{$ret{'log'}}, "Error: merge_requests is not an array.");
     	return \%ret;
     }
    
    # Write merge requests json file to disk.
    $repofs->write_input( $project_id, "import_gitlab_git_merge_requests.json", encode_json($mrs) );
    $repofs->write_output( $project_id, "gitlab_git_merge_requests.json", encode_json(\@mrs_ret) );

    # Write list of merge requests to the disk, csv.
    $csv = Text::CSV->new({binary => 1, eol => "\n"});
    @cols = ('id', 'title', 'state', 'description', 'assignee', 'web_url', 'labels',
	'merge_status', 'source_project_id', 'source_branch', 'target_project_id', 'target_branch',
	'upvotes', 'downvotes', 'user_notes_count', 'milestone', 'author', 
	     'created_at', 'updated_at');
    $csv_out = join(',', @cols) . "\n";
    foreach my $mr (@mrs_ret) {
        my @mrs = map { $mr->{$_} } @cols;
        $csv->combine(@mrs);
        $csv_out .= $csv->string();
    }    
    $repofs->write_output($project_id, "gitlab_git_merge_requests.csv", $csv_out);


    
    # Set user information for profile
    push(@{$ret{'log'}}, "[Plugins::GitLabGit] Writing user events file.");
    my $events = {};
    foreach my $u (sort keys %users) {
	$events->{$u} = $users{$u};
    }
    $repofs->write_users("GitLabGit", $project_id, $events);

    # Write static metrics json file to disk.
    $repofs->write_output($project_id, "metrics_git.json",
			  encode_json($ret{'metrics'}));

    # Write static metrics csv file to disk.
    my @metrics = sort map { $conf{'provides_metrics'}{$_} } keys %{$conf{'provides_metrics'}};
    $csv_out = join(',', sort @metrics) . "\n";
    $csv_out .= join(',', map { $ret{'metrics'}{$_} || '' } sort @metrics) . "\n";
    $repofs->write_output($project_id, "metrics_git.csv", $csv_out);
    
    # Recommendations    
    # if ( ($issue->{'state'} eq 'open') && ($date_changed < $t_1y->epoch) ) {
    # 	push( 
    # 	    @{$ret{'recs'}}, 
    # 	    { 'rid' => 'CI_BUILDS_', 
    # 	      'severity' => 1,
    # 	      'src' => 'GitLabIts',
    # 	      'desc' => 'Issue ' . $issue->{'iid'} . ' has not been updated during the last year, '
    # 		  . 'and is still open. Long-standing bugs have a negative impact on people\'s '
    # 		  . 'perception. You should either close the bug or add some more information.' 
    # 	    } 
    # 	    );
    # }
    
    # Generate R report

    # Now execute the main R script.
    push( @{$ret{'log'}}, "[Plugins::GitLabGit] Executing R main file." );
    my $r = Alambic::Tools::R->new();
    @{$ret{'log'}} = ( @{$ret{'log'}}, @{$r->knit_rmarkdown_inc( 
					     'GitLabGit', $project_id, 'gitlabci.Rmd',
					     { "gitlab.url" => $gl_url, 
					       "gitlab.id" => $gl_id}
					     )} );
    
    # And execute the figures R scripts.
    my @figs = grep( /.*\.rmd$/i, keys %{$conf{'provides_figs'}} );
    foreach my $fig (sort @figs) {
	push( @{$ret{'log'}}, "[Plugins::GitLabGit] Executing R fig file [$fig]." );
	@{$ret{'log'}} = ( @{$ret{'log'}}, @{$r->knit_rmarkdown_html( 'GitLabGit', $project_id, $fig )} );
    }
    
    return \%ret;
}

1;



1;
=encoding utf8

=head1 NAME

B<Alambic::Plugins::GitLabGit> - Retrieves Continuous Integration information from a 
GitLab instance.

=head1 DESCRIPTION

B<Alambic::Plugins::GitLabGit> - Retrieves Continuous Integration information from a 
GitLab instance.

Parameters: 

=over

=item * gitlab_url The URL of the remote GitLab instance, e.g. https://www.gitlab.com.

=item * gitlab_id The ID used to identify the project in the GitLab forge, 
e.g. bbaldassari/Alambic.

=item * gitlab_token The private token used to access the gitlab instance. 
The private token must be generated by a user who has global rights on all 
analysed projects. It is generated, downloaded and reset from the user's 
account page (/profile/account).

=back

For the complete description of the plugin see the user documentation on the web site: L<https://alambic.io/Plugins/Pre/GitLabGit.html>.

=head1 SEE ALSO

L<https://alambic.io/Plugins/Pre/GitLabGit.html>,

L<Mojolicious>, L<http://alambic.io>, L<https://bitbucket.org/BorisBaldassari/alambic>


=cut
